---
layout: post
title:  "Week 6: Effects"
date:   2022-10-31 01:46:10 -0400
categories: class update
comments: false
---

Page Overview:
* [Recap](#recap)
* [Listening](#listening)
* [New Tidal Notation](#new-tidal-notation)
   * [More Effects](#more-effects)
   * [Random in Mini Notation](#random-in-mini-notation)
* [Challenges](#challenges)

## Recap
Last time, we learned that patterns can be written throughout our Tidal code, including within effects, and we learned how to use fast and slow to contract and elongate pattern lengths. Here is one of your lines from the last ensemble performance.

```haskell
d1 $ n (fast "-8 <-1 2 -1 -4> <2 4>" "4 [~ 10] 4 7") # s "arpy" # gain "0.8 1.3 0.8 1.3 1.3"
```

The pattern passed as the first argument to `fast` results in some unexpected results - the first third of the pattern will repeat very quickly (`-8`), while the middle and final thirds will alternate due to the angle brackets. Because the notes and gain patterns are static, the resulting music is not too chaotic and sounds consistent with slight variations.

## Listening
In the weeks ahead, I will post videos from [LiveCode.NYC](https://livecode.nyc) our local real-time programming collective. This one is by Dan Gorelick & Stefan Pelikan with audio generated by TidalCycles.

<iframe width="560" height="315" src="https://www.youtube.com/embed/RKmO0nEjqfA?start=44" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Today's topics, effects and randomness, are used carefully at the start: The looping synth is filtered causing it to sound rounder or sharper while a little bit of randomness results in its octave jumping up some of the time. (Bonus: The progression of the synth is controlled using angle brackets!) The start also uses a similar structure to our ensemble performances from previous weeks: synth -> kick drum -> hihat -> snare...Listen onward for some longer samples and vocal parts!

## New Tidal Notation
Today we will learn more audio effects and how to include some randomness to add variation within our patterns.

### More Effects
A couple weeks ago, we covered effects that take inputs within a normal range (0–1) like `pan`, `djf` (dj filter), and `room` (reverb). Today, we'll learn a few more fun effects that take more unusual values as inputs. This is only a subset - the full list of effects may be found in the [Tidal Cycles Audio Effects Reference](http://tidalcycles.org/docs/reference/audio_effects).

#### Speed
Speed determines the rate of playback of a sample. Decimals slow playback down while negative numbers cause samples to play in reverse. You can use speed to tweak the sound of your drums and cymbals, and also use it to change the pitch of melodic sounds. For example, unlike `arpy` which gives us 10 notes to play with, the `gtr` folder only has the note c. By using the speed function first (instead of `n` or `s`) we can notate a pattern with different multiples of its fundamental frequency.

```haskell
d1 $ speed "<0.75 0.5 -0.75> <1 1.25 1> <1.5 2 -2.5>" # s "gtr"
```

#### Filters
Filters amplify and/or attenuate a certain range of frequency and have many uses. For example, you may want to bring out the lows of a kick drum or reduce the sharpness of a hihat using a low pass filter (`lpf`).

| Syntax | Description | Range or Inputs |
| ----------- | ----------- | ----------- |
| `djf` | dj filter | 0–1 |
| `lpf` | low pass filter | 0–20,000 |
| `hpf` | high pass filter | 0–20,000 |
| `bpf` | band pass filter | 0–20,000 |
| `vowel` | vowel sounds | a e i o u ~ |

```haskell
d1 $ n "5 [0]*6" # s "glitch" # lpf "20000 [100 200 300 800 1000 2000]"
```

#### Distortions
Distortion consists of a range of techniques for making a sound louder and noiser. Be careful using these as the sound can get quite loud! You might want to stick a gain at the end with a lower value to be safe and then increase as necessary.

| Syntax | Description | Range or Inputs |
| ----------- | ----------- | ----------- |
| `distort` | crunchy distortion | 0–1 |
| `squiz` | weird mixture of things | multiples of 2 |
| `crush` | bitcrusher | 16 for no reduction, 1 for significant reduction |

```haskell
d1 $ distort "~ 0.1 0.2 0.3 0.4 0.8" # n "<0 3 2 1>" # s "arpy" # gain 0.8
```

#### Delays
Delay is perhaps my favorite effect! Things get crazy when you use feedback and pass a delayed sound back into the delay.

| Syntax | Description | Range or Inputs |
| ----------- | ----------- | ----------- |
| `delay` | wet dry | 0–1 |
| `delayfeedback` | feedback amount | 0–1 (be careful approaching 1!) |
| `delaytime` | length of delay | seconds or cycles depending on `lock` |
| `lock` | whether `delaytime` is relative to cps | 1 for cps |

```haskell
d1 $ n "0 [2 5] 1 6" # s "arpy"
   # delay "0.8" # delayfeedback "0.5" # delaytime "<0.125 0.25 0.5 0.75>" # lock 1
```

#### Stacking Effects
You can stack effects by separating each with the pound sign `#`. I tend to put each effect or category of effect on it's own line as it makes the pattern more readable to me:

```haskell
d1 $ s "arpy(11, 16, <0 4>)"
   # pan "0.2 0.4 0.6 0.8 0.6 0.4"
   # djf "0.4 0.8"
   # room "0.9 0.1!15"
   # squiz "[2|4|10]*4"
   # speed "[0.75|1|1.5|2|4]*16"
```

Reminder: <kbd>shift</kbd> + <kbd>enter</kbd> only triggers one line of code, so if you are working with multiple lines use <kbd>control</kbd> or <kbd>cmd</kbd> + <kbd>enter</kbd> depending on your platform and leave an empty line between channels.

### Random in Mini Notation
I think randomness works best when used sparingly and alongside patterns that are held. Otherwise you just get random bleaps and bloops.

#### Question Marks ?
Typing a question mark `?` after any event means that there is a 50% random chance that that event will not occur. For example, in the following pattern, the hihat sound on the and of 2 will only be played about half the time.

```haskell
d1 $ s "hc [hc hc?] hc ~"
```

Additionally, adding a decimal after the question mark affects the probability of the note being dropped. Low values like `0.1` mean the event will occur frequently, while high values like `0.99` mean the event will rarely occur.

```haskell
d1 $ n "0 5?0.3 4 2?0.7" # s "feel"
```

#### Pipes [|]
In many programming languages, the vertical line also called the pipe located above the return key means OR. In Tidal Cycles, placing separating things in brackets by pipes means choose between the options randomly. For example, in the following code, a different arpy sound will be randomly selected once per cycle:

```haskell
d1 $ n "[0|1|2|3|4]" # s "arpy"
```
As usual, we can stick entire patterns in there (spaces for legibility):

```haskell
d1 $ n (fast 8 "[[0 0] | [1 0] | [2 0] | [0 3] | [4 0] ]") # s "arpy"
```

We can also pair randomness with other mini-notation like multiplication and even other randomness! For example, this pattern will play a sixteenth note hi-hat pattern, randomly select a sample with each hit (higher numbers are slightly more open), and rest 10% of the time.

```haskell
d1 $ n "[0|0|0|1|2|3|4]*16?0.1" # s "hc"
```

## Challenges
Compose a melodic pattern using the speed function and the `gtr` sample folder. 
* Bonus 1: Use other samples from the `gtr` pack. `gtr:1` and `gtr:2` use distortion. (You may want to add a `gain` and lower the volume!)
* Bonus 2: Integrate additional effects like `pan` and `delay`

```haskell
d1 $ speed "1 2 1 2" # s "gtr"
```

---

* [Previous Class](/laptopclass/class/update/2022/10/19/week5.html)
